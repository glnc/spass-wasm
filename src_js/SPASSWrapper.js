/**
 * A wrapper around the emscripten generated Module.
 * Until further investigation this is needed to call SPASS's main-method multiple times and to prevent memory issues.
 */

// import the gluecode for SPASS generated by emscripten
let SPASS = require('./SPASS.js');

let SPASSWrapper = {};
/**
 * Self-executing function to build the SPASSWrapper
 */
(function (SPASSWrapper) {
    /**
     * The constant page size for WebAssembly
     */
    let WASM_PAGE_SIZE_BYTES = 65536;

    /**
     * How many Memory we need in Bytes. This value should be the same as the value of the '-s TOTAL_MEMORY' option for emcc during the build process.
     */
    let INITIAL_TOTAL_MEMORY_BYTES = 335151104;

    /**
     * Number of memory pages we need
     */
    SPASSWrapper._INITAL_MEMORY_PAGES = Math.floor(INITIAL_TOTAL_MEMORY_BYTES / WASM_PAGE_SIZE_BYTES);

    /**
     * The Path where we look for the wasm binary created by emscripten.
     */
    SPASSWrapper._SPASS_WASM_PATH = 'SPASS.wasm';

    /**
     * Once we compiled the SPASS binare we store it here. We can then instanciate the binary multiple times. Once for each run of SPASS.
     */
    SPASSWrapper._compiledModule = undefined;

    /**
     * We create only one memory and save it here. We reset the memory between SPASS runs.
     */
    SPASSWrapper._memory = undefined;

    /**
     * We cannot run more then one SPASS instace at a time because they share the memory. So _locked should be true while SPASS runs. 
     */
    SPASSWrapper._locked = false;

    /**
     * We pass this function to the emscripten generated Module. The Module uses the function to get an instance of the SPASS binary.
     * See https://emscripten.org/docs/api_reference/module.html#Module.instantiateWasm.
     */
    SPASSWrapper._WASM_INITIALIZER = function (info, callback) {
        WebAssembly.instantiate(SPASSWrapper._compiledModule, info).then(instance => {
            callback(instance);
        });
        return {};
    }

    /**
     * Sets where we look for the wasm binary.
     * This is only possible while the binary is not loaded and compiled.
     */
    SPASSWrapper.setWasmPath = function (path) {
        if (SPASSWrapper._compiledModule) {
            return Promise.reject('The Binary was already loaded. Setting the path is only possible before the binary is loaded during init().');
        } else {
            SPASSWrapper._SPASS_WASM_PATH = path;
            return Promise.resolve('Ok');
        }
    }

    /**
     * Loads and compiles the wasm binary and creates the memory we need.
     */
    SPASSWrapper.init = function () {
        return fetch(SPASSWrapper._SPASS_WASM_PATH).then(response => {
            return response.arrayBuffer()
        }).then(buffer => {
            return WebAssembly.compile(buffer);
        }).then(compiledModule => {
            SPASSWrapper._compiledModule = compiledModule;
            SPASSWrapper._memory = new WebAssembly.Memory({ initial: SPASSWrapper._INITAL_MEMORY_PAGES });
            return Promise.resolve();
        });
    }

    /**
     * Run SPASS.
     * SPASSWrapper.init() gets called if needed.
     * @param {string} data - The contents of the file you want to work on with SPASS
     * @param {string[]} options - Further commandline options. For example "-Flotter"
     * @returns {Promise<string>}
     */
    SPASSWrapper.run = function (data, options) {
        // Is there a SPASS instance running?
        if (SPASSWrapper._locked) {
            return Promise.reject('SPASS is buisy at the Moment. Please try again.');
        }
        // Now one instance is running
        SPASSWrapper._locked = true;
        // We build a promise...
        let r = Promise.resolve('');
        // if the SPASSWrapper is not initalized, we need to initalize first.
        if (!SPASSWrapper._memory || !SPASSWrapper._compiledModule) {
            r = r.then(_ => {
                return SPASSWrapper.init();
            }).then(_ => {
                return Promise.resolve();
            });
        }
        // 
        r = r.then(_ => {
            // build a new promise that resolves with the result of the SPASS invocation
            return new Promise((resolve, reject) => {
                // We want to use our existing memory and the precompiled binary
                let moduleOpts = {
                    instantiateWasm: SPASSWrapper._WASM_INITIALIZER,
                    'asm.js': false,
                    'wasmMemory': SPASSWrapper._memory
                };
                // initalize the SPASS module,...
                SPASS(moduleOpts).then(SPASSInstance => {
                    // ... then invoke the main Method.
                    let result = SPASSInstance.runSPASS(data, options);
                    // Cleanup the Memory for the next run.
                    new Uint32Array(SPASSWrapper._memory.buffer).fill(0);
                    // Memory is cleaned, and the SPASS can continue
                    SPASSWrapper._locked = false;
                    // 
                    resolve(result);
                });
            });
        });
        return r;
    }
})(SPASSWrapper);

module.exports = SPASSWrapper;