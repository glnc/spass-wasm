/**
 * A wrapper around a CommonJS module generated by emscripten
 * preventing memory issues when running the module multiple times.
 */

/**
 * The total memory in bytes. This value should be the same as the value of TOTAL_MEMORY in "-s TOTAL_MEMORY" argument for emcc.
 */
const INITIAL_TOTAL_MEMORY_BYTES = 335151104;

/**
 * The page size in bytes.
 */
const PAGE_SIZE_BYTES = 65536;

/**
 * The number of memory pages.
 */
const INITIAL_MEMORY_PAGES = Math.floor(INITIAL_TOTAL_MEMORY_BYTES / PAGE_SIZE_BYTES);

const Wrapper = {};

/**
 * The CommonJS module generated by emscripten.
 */
Wrapper._MODULE = undefined;

/**
 * The path of the WASM file created by emscripten.
 */
Wrapper._WASM_PATH = undefined;

/**
 * Once the WASM file is compiled we store a reference to that module. We can then instantiate that module multiple times, once for each run.
 */
Wrapper._compiledModule = undefined;

/**
 * We cannot run more than one instance at a time because they share the memory. So _locked should be true while an instance is running.
 */
Wrapper._locked = false;

/**
 * The (shared) memory to use by instances. It is reset after each run.
 */
Wrapper._memory = undefined;

/**
 * Set the CommonJS module created by emscripten to wrap.
 * This is only possible before calling init().
 */
Wrapper.setModule = function (module) {
	if (Wrapper._compiledModule) {
		return Promise.reject("Setting the module is not allowed after calling init().");
	} else {
		Wrapper._MODULE = module;
		return Promise.resolve();
	}
};

/**
 * Set the path of the WASM file created by emscripten.
 * This is only possible before calling init().
 */
Wrapper.setWASM = function (path) {
	if (Wrapper._compiledModule) {
		return Promise.reject("Setting the path is not allowed after calling init().");
	} else {
		Wrapper._WASM_PATH = path;
		return Promise.resolve();
	}
};

/**
 * Loads and compiles the WASM file and creates the memory to use.
 */
Wrapper.init = function () {
	if (!(Wrapper._MODULE && Wrapper._WASM_PATH)) {
		return Promise.reject("Please set the module to wrap and the path of the WASM file first.");
	}
	else {
		return fetch(Wrapper._WASM_PATH).then(data => {
			return data.arrayBuffer()
		}).then(buffer => {
			return WebAssembly.compile(buffer);
		}).then(compiledModule => {
			Wrapper._compiledModule = compiledModule;
			Wrapper._memory = new WebAssembly.Memory({ initial: INITIAL_MEMORY_PAGES });
			return Promise.resolve();
		});
	}
};

/**
 * A callback function to let WASM get an instance of the compiled module.
 * See https://emscripten.org/docs/api_reference/module.html#Module.instantiateWasm.
 */
Wrapper._WASM_INITIALIZER = function (info, callback) {
	WebAssembly.instantiate(Wrapper._compiledModule, info).then(instance => {
		callback(instance);
	});
	return {};
};

/**
 * Run the wrapped module.
 * init() gets called before if needed.
 * @param {string} input - The content of the input file
 * @param {string[]} args - Additional command line arguments
 * @returns {Promise}
 */
Wrapper.run = function (input, args) {
	if (Wrapper._locked) {
		return Promise.reject("An instance is already running");
	}

	Wrapper._locked = true;

	let result = Promise.resolve();

	// Call init() if needed
	if (!(Wrapper._compiledModule && Wrapper._memory)) {
		result = result.then(() => {
			return Wrapper.init();
		}).then(() => {
			return Promise.resolve();
		});
	}

	result = result.then(_ => {
		return new Promise(resolve => {
			Wrapper._MODULE({
				instantiateWasm: Wrapper._WASM_INITIALIZER,
				"asm.js": false,
				"wasmMemory": Wrapper._memory
			}).then(instance => {
				let result = instance.run(input, args);
				// reset the memory for the next run.
				new Uint32Array(Wrapper._memory.buffer).fill(0);

				Wrapper._locked = false;
				resolve(result);
			});
		});
	});

	return result;
};

module.exports = Wrapper;
